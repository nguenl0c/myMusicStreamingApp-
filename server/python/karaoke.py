import argparse
import json
import os
from datetime import timedelta

#server/python/karaoke.py
import stable_whisper

# Tải mô hình Whisper (bạn có thể chọn 'tiny', 'base', 'small', 'medium', 'large')
# Model 'base' hoặc 'small' là đủ tốt cho thử nghiệm ban đầu
def format_srt_timestamp(t: float) -> str:
    if t is None:
        t = 0.0
    td = timedelta(seconds=max(0.0, t))
    # SRT: HH:MM:SS,mmm
    total_seconds = int(td.total_seconds())
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    milliseconds = int((td.total_seconds() - total_seconds) * 1000)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"

def write_srt(result, path: str):
    lines = []
    idx = 1
    for seg in result.segments:
        start = format_srt_timestamp(getattr(seg, 'start', 0.0))
        end = format_srt_timestamp(getattr(seg, 'end', 0.0))
        text = getattr(seg, 'text', '').strip()
        if not text:
            continue
        lines.append(str(idx))
        lines.append(f"{start} --> {end}")
        lines.append(text)
        lines.append("")
        idx += 1
    with open(path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))

def write_lrc(result, path: str, title: str = ""):
    def ts(t: float) -> str:
        if t is None:
            t = 0.0
        m = int(t // 60)
        s = int(t % 60)
        cs = int((t - int(t)) * 100)
        return f"[{m:02d}:{s:02d}.{cs:02d}]"

    with open(path, 'w', encoding='utf-8') as f:
        f.write("[ar: Generated by stable-ts]\n")
        if title:
            f.write(f"[ti: {title}]\n")
        f.write("\n")
        for seg in result.segments:
            words = getattr(seg, 'words', None)
            if words:
                for w in words:
                    start = getattr(w, 'start', getattr(seg, 'start', 0.0))
                    text = getattr(w, 'word', '').strip()
                    if text:
                        f.write(f"{ts(start)}{text}\n")
            else:
                # fallback theo segment
                start = getattr(seg, 'start', 0.0)
                text = getattr(seg, 'text', '').strip()
                if text:
                    f.write(f"{ts(start)}{text}\n")

def main():
    parser = argparse.ArgumentParser(description='Karaoke transcription using stable-ts (stable_whisper).')
    parser.add_argument('--input', required=True, help='Đường dẫn file âm thanh đầu vào')
    parser.add_argument('--output_dir', required=True, help='Thư mục xuất kết quả')
    parser.add_argument('--model', default='large-v3-t', help='Model: tiny|base|small|medium|large-v2|large-v3|large-v3-turbo')
    parser.add_argument('--language', default='auto', help='Mã ngôn ngữ, ví dụ: vi|en|auto')
    parser.add_argument('--device', default=None, help='cpu|cuda')
    parser.add_argument('--formats', default='srt', help='Định dạng đầu ra: srt|lrc|both')
    args = parser.parse_args()

    os.makedirs(args.output_dir, exist_ok=True)

    print("Đang tải mô hình stable-ts...", flush=True)
    model = stable_whisper.load_model(args.model, device=args.device)

    print(f"Đang phiên âm: {args.input}", flush=True)
    kw = {}
    if args.language and args.language != 'auto':
        kw['language'] = args.language
    result = model.transcribe(args.input, **kw)

    srt_path = os.path.join(args.output_dir, 'lyrics.srt')
    lrc_path = os.path.join(args.output_dir, 'lyrics.lrc')

    if args.formats in ('srt', 'both'):
        write_srt(result, srt_path)
    if args.formats in ('lrc', 'both'):
        title = os.path.basename(args.input)
        write_lrc(result, lrc_path, title=title)

    out = {
        'status': 'success',
        'srt': srt_path if os.path.exists(srt_path) else None,
        'lrc': lrc_path if os.path.exists(lrc_path) else None,
    }
    print(json.dumps(out), flush=True)

if __name__ == '__main__':
    main()